/* 题目
            分组
*   描述
            有n 个正整数排成一排，你要将这些数分成m 份
    （同一份中的数字都是连续的，不能隔开），同
     时数字之和最大的那一份的数字之和尽量小。
*   输入格式
            输入的第一行包含两个正整数n，m。
            接下来一行包含n 个正整数。
*   输出格式
            输出一个数，表示最优方案中，数字之和最大
     的那一份的数字之和。
*   输入样例1
            5 2
            2 1 2 2 3
*   输出样例
            5
*   样例1解释
            若分成2和1、2、2、3，则最大的那一份是1+2+2+3=8；
            若分成2、1和2、2、3，则最大的那一份是2+2+3=7；
            若分成2、1、2和2、3，则最大的那一份是2+1+2或者是2+3，都是5；
            若分成2、1、2、2和3，则最大的那一份是2+1+2+2=7。
            所以最优方案是第三种，答案为5。
*   限制
            对于50%的数据，n ≤ 100，给出的n个正整数不超过10；
            对于100%的数据，m ≤ n ≤ 300000，给出的n个正整数不超过1000000。
            时间：4 sec
            空间：512 MB
*   提示
            [看到“最大的最小”这一类语言，一定要想二分能不能做。]
            [我们二分最大的那一份的和d，然后从左向右分组，在一组中，
     在和不超过d的情况下尽量往右分。若最终分出来的组数小于等于
     m，则这显然是合法的（我们在分出来的组里随便找个地方切开，
     总能变到m组，且每组的和不超过d）]
            [这个d显然是单调的，即，若和不超过d能分成m组，则和不超
     过d+1也是能分成m组的，故二分正确。]
*   思路
            本题的解法完全出乎我一向的思考方式，非常具有启发性。乍看
     本题，我的解法偏向暴力，即n 个数，m 份，并且m<=n，相当于用隔板
     法求组合数，共有C(n-1, m-1) 种组合，统计每一种组合中，和最大的那一
     份的和，然后比较所有组合的和最大的那一份，找出其中最小的就是
     答案。
            按照提示，本题最合理的解法如下，细细体会其中的思路。
            题中要求数字之和必须由输入所给的连续的数构成，所有这些数的
     总和假设为S，那么对每一份的加和结果s 一定满足: s<=S，所求即为在
     [1, S] 中，找到一个s，该s 能够使整个数列恰好分为m 份并且s 是m 份中和
     最大的，该s 是在[1,S] 中能够满足该条件的最小的s。
            由此，本题抽象为在[1,S] 中，找到一个满足条件的最小的s。条件为
     1) 可以分为m 份
     2) s 是[1,S] 中符合上一个条件的最小值。
            s 是[1,S] 中某一个值时，从左到右依次分组，每组的和都不大于所选
     的s，由此会得到该s 下的分组数。因为[1,S] 中，这个区间里的每一个数
     都是不同的，所以让s 取遍这个区间里的每一个数，都会对应不同的分
     组数或分组数相同但组内情况不同的结果。
            对于在给定范围内找某一个数的问题，理应想到要使用二分查找。
     这里的二分查找规则应为如下，
     1) s 属于[1,S]，如果此时分的份数cur_m < m，说明s 选大了，应减小s 继续迭代
     2) s 属于[1,S]，如果此时分的份数cur_m > m，说明s 选小了，应增大s 继续迭代
     3) s 属于[1,S]，如果此时分的份数cur_m == m，说明s 初步符合条件，但无法保
     证该s 是符合条件的最小的s，所以仍需继续减小s 做进一步的迭代。
            注意，当cur_m < m 时，cur_m 可以继续细分为m 份，只是被细分的份的和
     比当前对应的s 越来越小了(分为cur_m 份时，这些份的和是紧贴着s 的)；
     当cur_m > m 时，如果再细分cur_m，只会让当前的份数更大于m，所以应该
     合并当前的份数使其接近m，但如果合并当前的份数，势必让合并后的那
     一份的和大于当前对应的s，所以不能合并，只能向上取更大的s。
            上面的注意事项非常重要。因为使用二分是有条件的，即必须在有序
     数列中使用二分。虽然s 是在有序区间[1,S] 中取值，但这里使用的二分条件
     却不是[1,S] 中每个数的大小，而是s 在[1,S] 中取值时，与s 取值对应的cur_m 与
     m 的关系。s 不同，对应的cur_m 也不同，并且随着s 的增加，cur_m 在逐渐减少，
     这里的cur_m 是指s 所对应的最小份数(因为通过继续细分可以增加份数，所以
     考虑最小份数才有意义)。因为cur_m 随着s 的增减而减少，具有单调性，因此
     可以使用二分查找。
*   启发
            蛮力算法是找到所有的组合，再通过比较所有组合的最大数列值来
     得到最终的结果。       
            实际的算法是找到题中所求值的取值范围，在这个范围中通过使用
     高效的查找算法得到符合条件的最终结果。
            蛮力算法的思路方向是从已知条件逐步推导、计算出结果；
            实际算法的思路方向是从可能的结果范围中依据已知条件逐步排查
     出最终的结果。
            前者是从前往后正向思考，而后者是从后往前逆向思考，这种从后
     往前逆向思考的思路才是本题的关键!!!
            另，本题的思路只能用于解决数列中没有负数的情况，如果有负数，
     需要使用其他算法，可以参考greatest slice 问题。
*/

#include <iostream>
#include <cstdio> 
    
using namespace std;

typedef int s32;
typedef long long s64;

s32 g_n;
s32 g_m;
s32 *g_mem; 
s64 g_total_sum;

s32 calculate_m(s64 upper_bound)
{
    s32 i, tmp_m;
    s64 tmp_sum;

    tmp_m = 0;
    tmp_sum = 0;

    for (i = 1; i <= g_n; i++) {
        /* 如果upper_bound 选的太小，会进入该判断
              *  其实可以在初始化的时候用堆选出当前数列中最大的数，
              *  然后在第一次二分的时候直接让lo 等于这个数，这里就不
              *  用添加这个判断，并且还相对减少了一些二分查找范围。
              *  细想下来，时间上有点入不敷出，用这个判断更简单而且
              *  花费时间更少。
              */
        if (g_mem[i] > upper_bound) {
            return 0x7fffffff;
        }
        
        if (tmp_sum + g_mem[i] <= upper_bound) {
            if (g_n == i) {
                tmp_m++;
                break;
            }
            tmp_sum += g_mem[i];
            continue;
        }
        
        tmp_m++;
        tmp_sum = g_mem[i];
        if (g_n == i) {
            tmp_m++;
            break;
        }
    }

    return tmp_m;
}

void process()
{
    s32 tmp_m;
    s64 lo, hi, mid;

    lo = 1;
    hi = g_total_sum;
    while (lo <= hi) {
        mid = (lo + hi) / 2;
        tmp_m = calculate_m(mid);

        // mid 值即s 选小了
        if (tmp_m > g_m) {
            lo = mid + 1;
            continue;
        }

        /* tmp_m <= g_m
              *   对于tmp_m < g_m: mid 值即s 选大了，tips: 随着s 的增加，cur_m 在递减
              *   对于tmp_m == g_m: s 对应的cur_m 虽然与m 相同，但要继续找符合条件的最小的s
              */
        hi = mid - 1;
    }

    printf("%lld\n", hi+1);

    return;
}

void init()
{
    s32 i;

    scanf("%d %d", &g_n, &g_m);
    getchar();

    g_total_sum = 0;

    // 从1 开始，方便些
    g_mem = new s32[g_n+1];
    for (i = 1; i <= g_n; i++) {
        scanf("%d", &g_mem[i]);
        getchar();

        g_total_sum += g_mem[i];
    }
    
    return;
}

void end()
{
    delete[] g_mem;

    return;
}

int main()
{
    init();

    process();

    end();

    return 0;
}
