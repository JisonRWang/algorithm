/* 题目
            序列计数
*   描述
            给定一个n个整数的序列以及一个非负整数d，请你输出这
    个序列中有多少个连续子序列（长度大于1），满足该子序列
    的最大值最小值之差不大于d。
            连续子序列：序列1 2 3中长度大于1的连续子序列有，
            1 2
            2 3
            1 2 3
*   输入格式
            第一行包含两个整数n,d。
            接下来一行包含n个整数。
*   输出格式
            输出一个整数，表示满足条件的连续子序列个数。
*   输入样例1
            8 5
            5 5 4 8 -10 10 0 1
*   输出样例
            7
*   样例1解释
            满足条件的连续子序列有：
            5 5
            5 5 4
            5 5 4 8
            5 4
            5 4 8
            4 8
            0 1
*   限制
            对于60%的数据，n ≤ 5000；
            对于100%的数据，n ≤ 300000。
            保证所有整数的绝对值不超过10^9，d不超过2×10^9。
            时间：10 sec
            空间：512 MB
*   提示
            [考虑分治。]
            [令函数solve(l, r)表示统计[l, r]中合法的连续子序列个数，
     mid为(l+r)/2（下取整），那么]
            [solve(l, r) = 0, 当l = r](tips: 子序列长度要求大于1)
            [solve(l, r) = solve(l, mid) + solve(mid + 1, r) + cal(l, r, mid)，当l≠r]
            [其中cal(l, r, mid)表示在左端点在区间[l, mid]中、右端点在区
     间[mid + 1, r]中的符合要求的连续子序列数目]
            [那么答案就是solve(1, n)。]
            [至于cal(l, r, mid)怎么算，大家可以仔细思考思考。（右端
     点是有单调性的）]
            [**注意答案要用long long**]
            [（另外这题也可以用线性的方法做哦~有兴趣去搜一搜
     单调栈）]
*   我的思路
            直接想到的就是蛮力算法。从第一个数开始，让这个数加d
     和减d，得到一个范围，然后开始往右，右边的数只要落在这个
     范围内，就算一个符合条件的序列，直到遇到第一个在这个范
     围之外的数，然后从第二个数开始继续此过程。
            想破解该题，最关键的就是想清楚如何找子序列(无论是否存
     在d 这个限制)。子序列的查找其实很简单，以某个数为起点，假
     设有一个终点指针，该指针最初停留在这个数上，然后终点指针
     每向右移动一个位置，就表示以该数为起点的子序列个数又增加
     了一个；当终点指针移动到最后一个数后，起点指针向右移动一
     个位置，表示以这个数为新的起点，终点指针此时再次从这个新
     起点开始依次向右移动，每移动一个位置，就相当于以这个新起
     点为起点的子序列个数又增加了一个。这样做可以得到全部的子
     序列，无一遗漏，想通这点的关键在于要清醒的认识到，所谓不
     同的子序列，无非就是起点和终点都不相同的子序列(这里谈论的
     子序列中每一个数在原序列中都是连续的)，如果把每一个能够作
     为起点的数都找到并让他们作为起点去找各自的终点，那么就一
     定可以得到所有的子序列。一开始之所以会担心这种方法找不到
     全部的子序列，是因为自己一开始找子序列的方式并不是以某个
     数为起点，先将以这个数为起点的全部子序列找到，再找以下一
     个数为起点的全部子序列，而是在没有找全某一个数的全部子序
     列的的情况下，就开始找以下一个数为起点的子序列，最后再返
     回来找最早那个数为起点的其他子序列，例如，找1 2 3 这个数列
     的子序列，按以前的找法，找出来的子序列顺序是1 2，2 3，1 2 3，
     而使用新的找法，找出来的子序列顺序是1 2，1 2 3，2 3。很明显新
     方法更清晰，更有条理。再例如，找1 2 3 4 这个数列的子序列，按
     新方法，就是"1 2","1 2 3","1 2 3 4","2 3","2 3 4","3 4"。总结一下以前的方法，就
     是按照组成子序列的数的个数去找子序列，先两个两个找，再三个
     三个找，再四个四个找......
            本题要用新的方法去做。
            本题在找子序列的基础上，增加了一个限制d，统计子序列中最
     大值和最小值之差不大于d的子序列个数。此时，要想清楚以下几
     件事(性质):
     1) 以某一个数为起点，终点指针每向右移动一个位置，说明以该数
     为起点的子序列个数增加一个，也就是说，以a[i] 为起点的子序列个数
     为(假设末尾指针为ranger): ranger -i。注意，要求子序列的长度大于1，所以
     直接ranger-i 而没有加1。
     2) 以某一个数为起点，如果终点指针指向右面某一个数x 时，出现了
     最值之差大于d 的情况，说明x 左边那个数就已经是当前起点所能取
     到的最长的子序列位置了，从x 开始往右所有的数都不能作为以当前
     这个数为起点的子序列中的数。当终点指针指向x 时出现了最值之差
     大于d 的情况，说明这个x 一定影响了以当前起点为开头的序列的最大
     值或最小值，使当前最大值变大或使当前最小值更小，导致差值大于
     d。如果此时终点指针继续向右，如果终点指针指向的新值y 的大小处
     在当前序列最值之间，则无法影响当前最值，那么当前最值之差仍然
     是大于d 的，这样的子序列仍然不符合题干要求；如果终点指针指向的
     新值y 大大小处在当前序列最值之外，则会影响到当前序列的最值，使
     当前序列的最大值更大或使当前序列的最小值更小，因为当前序列的最
     值之差就已经大于d 了，如果新的最值再被更新，那么差值会更加大于d。
     因此，当找到第一个使当前序列最值之差大于d 的数，也就说明以当前
     这个序列的起始点作为开头来找子序列的动作要结束了，要开始更换
     新的序列开头了。
     3) 设a[i] 表示序列起点，a[x-1] 是以a[i] 开头能取到的符合条件的最右侧
     的数，a[x] 是第一个使以a[i] 开头的序列最值之差大于d 的数。则以a[i+1]
     开头的序列能取到的符合条件的最右侧的数的位置y 一定有y >= x-1。因为
     在[a[i], a[x-1]] 中的最值之差不大于d，那么在[a[i+1], a[x-1]] 中的最值之差也一定
     不大于d。如果[a[i], a[x-1]] 中的最值落在[a[i+1], a[x-1]] 区间，那么以a[i+1] 为起点
     的子序列的y 仍然等于x-1；如果a[i] 恰好是[a[i], a[x-1]] 中的最值，那么对于
     [a[i+1], a[x-1]] 区间来讲，该区间的最值就会被影响，以a[i+1] 开头的序列的最大
     值变小或最小值变大，此时，y 就有可能大于x-1，无论如何，a[i] 往右每
     一个数的y 都一定不会小于前一个数的y。
*/

#include <iostream>
#include <cstdio> 
    
using namespace std;

typedef long long s64;

int g_n;
int g_d;
int* g_mem;
int* g_max_mem;
int* g_min_mem;

int min_comparison(int tmp_a, int tmp_b)
{
    int tmp;

    tmp = (tmp_a < tmp_b) ? tmp_a : tmp_b;

    return tmp;
}

int max_comparison(int tmp_a, int tmp_b)
{
    int tmp;

    tmp = (tmp_a < tmp_b) ? tmp_b: tmp_a;

    return tmp;
}

s64 binary_process(int lo, int hi)
{
    s64 cnt;
    int i, mid, ranger;
    int tmp_max, tmp_min;
    int right_max, right_min;

    // 递归基，题意要求序列长度必须大于1
    if (lo == hi) {
        return 0;
    }

    mid = (lo + hi) / 2;

    // 分别计算左右两半各自符合要求的序列个数
    cnt = binary_process(lo, mid) + binary_process(mid+1, hi);

    // 左右两半合到一起后计算总的符合要求的序列个数

    /* 从右向左依次统计[lo, mid] 区间的最值。
       *   当从左向右逐个分析时，就可以得到当前数往右的最值
       *   这个过程和"求最大字典序" 那道题非常像
       */
    for (i = mid; i >= lo; i--) {
        g_min_mem[i] = (i == mid) ? g_mem[i] : min_comparison(g_mem[i], g_min_mem[i+1]);
        g_max_mem[i] = (i == mid) ? g_mem[i] : max_comparison(g_mem[i], g_max_mem[i+1]);
    }

    /* 让[lo, mid] 区间中的每个数都分别作为起点，逐个查看[mid+1, hi]
       *   中的每个数能否加入到左面成为新的序列。这里利用性质1)。
       *   right_min/right_max 分别记录从左到右处理右半部分时右半部分的最值
       */
    ranger = mid;
    right_min = g_mem[ranger+1];
    right_max = g_mem[ranger+1];
    for (i = lo; i <= mid; i++) {
        while (ranger+1 <= hi) {
            tmp_min = min_comparison(right_min, g_mem[ranger+1]);
            tmp_max = max_comparison(right_max, g_mem[ranger+1]);
            
            if (max_comparison(g_max_mem[i], tmp_max) - min_comparison(g_min_mem[i], tmp_min) > g_d) {
                // 直接跳出循环，因为性质2)
                break;
            }

            // i 逐渐向右走，ranger 也一直向右而不用返回向左，因为性质3)
            ranger++;
            right_min = tmp_min;
            right_max = tmp_max;
        }

        /* 对应性质1)，mid 左边的已经在二分的时候单独计算出来了，
              *   现在只要把右半部分新增的加上即可。
              */
        cnt += ranger - mid;
    }

    return cnt;
}

void process()
{
    s64 cnt;

    cnt = binary_process(1, g_n);
    printf("%lld\n", cnt);

    return;
}

void init()
{
    int i;

    scanf("%d %d", &g_n, &g_d);
    getchar();

    // 从1 开始
    g_mem = new int[g_n+1];
    g_min_mem = new int[g_n+1];
    g_max_mem = new int[g_n+1];

    for (i = 1; i <= g_n; i++) {
        scanf("%d", &g_mem[i]);
        getchar();
    }

    return;
}

void end()
{
    delete[] g_mem;
    delete[] g_min_mem;
    delete[] g_max_mem;

    return;
}

int main()
{
    init();

    process();

    end();

    return 0;
}

